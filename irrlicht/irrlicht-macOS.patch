diff -ur source/Irrlicht/CGUIEditBox.cpp source-fixed/Irrlicht/CGUIEditBox.cpp
--- source/Irrlicht/CGUIEditBox.cpp	2019-10-03 18:30:21.000000000 -0400
+++ source-fixed/Irrlicht/CGUIEditBox.cpp	2019-10-03 18:31:24.000000000 -0400
@@ -287,9 +287,11 @@
 				const s32 realmbgn = MarkBegin < MarkEnd ? MarkBegin : MarkEnd;
 				const s32 realmend = MarkBegin < MarkEnd ? MarkEnd : MarkBegin;
 
-				core::stringc s;
-				s = Text.subString(realmbgn, realmend - realmbgn).c_str();
-				Operator->copyToClipboard(s.c_str());
+				const int max_char_size = sizeof(wchar_t) * 3 / 2;
+				int max_size = (realmend - realmbgn)*max_char_size + 1;
+				c8 *s = new char[max_size];
+				wcstombs(s, Text.subString(realmbgn, realmend-realmbgn).c_str(), max_size);
+				Operator->copyToClipboard(s);
 			}
 			break;
 		case KEY_KEY_X:
@@ -300,9 +302,11 @@
 				const s32 realmend = MarkBegin < MarkEnd ? MarkEnd : MarkBegin;
 
 				// copy
-				core::stringc sc;
-				sc = Text.subString(realmbgn, realmend - realmbgn).c_str();
-				Operator->copyToClipboard(sc.c_str());
+				const int max_char_size = sizeof(wchar_t) * 3 / 2;
+				int max_size = (realmend - realmbgn)*max_char_size + 1;
+				c8 *s = new char[max_size];
+				wcstombs(s, Text.subString(realmbgn, realmend-realmbgn).c_str(), max_size);
+				Operator->copyToClipboard(s);
 
 				if (isEnabled())
 				{
diff -ur source/Irrlicht/MacOSX/AppDelegate.h source-fixed/Irrlicht/MacOSX/AppDelegate.h
--- source/Irrlicht/MacOSX/AppDelegate.h	2019-10-03 18:30:22.000000000 -0400
+++ source-fixed/Irrlicht/MacOSX/AppDelegate.h	2019-10-03 18:32:11.000000000 -0400
@@ -10,14 +10,16 @@
 #import <Cocoa/Cocoa.h>
 #import "CIrrDeviceMacOSX.h"
 
-@interface AppDelegate : NSObject
+@interface AppDelegate : NSTextView <NSApplicationDelegate>
 {
 	BOOL			_quit;
 	irr::CIrrDeviceMacOSX	*_device;
+	NSMenu *_dockMenu;
 }
 
 - (id)initWithDevice:(irr::CIrrDeviceMacOSX *)device;
 - (BOOL)isQuit;
+- (NSMenu *)applicationDockMenu:(NSApplication *)sender;
 
 @end
 
diff -ur source/Irrlicht/MacOSX/AppDelegate.mm source-fixed/Irrlicht/MacOSX/AppDelegate.mm
--- source/Irrlicht/MacOSX/AppDelegate.mm	2019-10-03 18:30:22.000000000 -0400
+++ source-fixed/Irrlicht/MacOSX/AppDelegate.mm	2019-10-03 18:32:11.000000000 -0400
@@ -13,6 +13,7 @@
 {
 	self = [super init];
 	if (self) _device = device;
+	_dockMenu = [[[NSMenu alloc] init] autorelease];
 	return (self);
 }
 
@@ -74,6 +75,34 @@
 	return (_quit);
 }
 
+- (void)keyDown:(NSEvent *)event
+{
+	[self interpretKeyEvents:@[event]];
+}
+
+- (void)insertText:(id)string
+{
+	[self setString: @""];
+	if ([string isKindOfClass:[NSAttributedString class]])
+	{
+		_device->handleInputEvent([[string string] UTF8String]);
+	}
+	else
+	{
+		_device->handleInputEvent([string UTF8String]);
+	}
+}
+
+- (void)doCommandBySelector:(SEL)selector
+{
+	_device->processKeyEvent();
+}
+
+- (NSMenu *)applicationDockMenu:(NSApplication *)sender
+{
+	return _dockMenu;
+}
+
 @end
 
 #endif // _IRR_COMPILE_WITH_OSX_DEVICE_
diff -ur source/Irrlicht/MacOSX/CIrrDeviceMacOSX.h source-fixed/Irrlicht/MacOSX/CIrrDeviceMacOSX.h
--- source/Irrlicht/MacOSX/CIrrDeviceMacOSX.h	2019-10-03 18:30:22.000000000 -0400
+++ source-fixed/Irrlicht/MacOSX/CIrrDeviceMacOSX.h	2019-10-03 18:31:24.000000000 -0400
@@ -95,6 +95,8 @@
 		void setMouseLocation(int x, int y);
 		void setResize(int width, int height);
 		void setCursorVisible(bool visible);
+		void handleInputEvent(const char *str);
+		void processKeyEvent();
 
 	private:
 
diff -ur source/Irrlicht/MacOSX/CIrrDeviceMacOSX.mm source-fixed/Irrlicht/MacOSX/CIrrDeviceMacOSX.mm
--- source/Irrlicht/MacOSX/CIrrDeviceMacOSX.mm	2020-01-21 17:47:34.000000000 -0500
+++ source-fixed/Irrlicht/MacOSX/CIrrDeviceMacOSX.mm	2020-02-22 20:28:06.000000000 -0500
@@ -7,6 +7,7 @@
 
 #ifdef _IRR_COMPILE_WITH_OSX_DEVICE_
 
+#import <AppKit/AppKit.h>
 #import <Cocoa/Cocoa.h>
 #import <OpenGL/gl.h>
 #ifndef __MAC_10_6
@@ -496,7 +497,7 @@
 		{
 			[[NSAutoreleasePool alloc] init];
 			[NSApplication sharedApplication];
-			[NSApp setDelegate:(id<NSFileManagerDelegate>)[[[AppDelegate alloc] initWithDevice:this] autorelease]];
+			[NSApp setDelegate:[[[[AppDelegate alloc] initWithDevice:this] initWithFrame:NSZeroRect] autorelease]];
 			[NSBundle loadNibNamed:@"MainMenu" owner:[NSApp delegate]];
 			[NSApp finishLaunching];
 		}
@@ -592,6 +593,38 @@
 	CGLContext = NULL;
 }
 
+void CIrrDeviceMacOSX::processKeyEvent()
+{
+	irr::SEvent ievent;
+	NSEvent *event = [[NSApplication sharedApplication] currentEvent];
+	postKeyEvent(event, ievent, true);
+}
+
+void CIrrDeviceMacOSX::handleInputEvent(const char *cStr)
+{
+	SEvent ievent;
+
+	// TODO: we should have such a function in core::string
+	size_t lenOld = strlen(cStr);
+	wchar_t *ws = new wchar_t[lenOld + 1];
+	size_t len = mbstowcs(ws,cStr,lenOld);
+	ws[len] = 0;
+	irr::core::stringw widep(ws);
+	delete[] ws;
+
+	ievent.EventType = irr::EET_KEY_INPUT_EVENT;
+	ievent.KeyInput.Key = (irr::EKEY_CODE)0;
+	ievent.KeyInput.PressedDown = true;
+	ievent.KeyInput.Shift = false;
+	ievent.KeyInput.Control = false;
+
+	for (int i = 0; i < widep.size(); ++i)
+	{
+		ievent.KeyInput.Char = widep[i];
+		postEventFromUser(ievent);
+	}
+}
+
 bool CIrrDeviceMacOSX::createWindow()
 {
 	CGDisplayErr error;
@@ -881,6 +914,8 @@
 			newSwapInterval = (CreationParams.Vsync) ? 1 : 0;
 			CGLSetParameter(CGLContext,kCGLCPSwapInterval,&newSwapInterval);
 		}
+
+		[[Window contentView] addSubview:(AppDelegate*)[NSApp delegate]];
 	}
 
 	return (result);
@@ -901,6 +936,8 @@
 	{
 		NSRect driverFrame = [Window contentRectForFrameRect:[Window frame]];
 		getVideoDriver()->OnResize(core::dimension2d<u32>( (s32)driverFrame.size.width, (s32)driverFrame.size.height));
+		DeviceWidth = (s32)driverFrame.size.width;
+		DeviceHeight = (s32)driverFrame.size.height;
 	}
 	else
 		getVideoDriver()->OnResize(core::dimension2d<u32>( (s32)width, (s32)height));
@@ -971,6 +1008,21 @@
 	os::Timer::tick();
 	storeMouseLocation();
 
+	auto focusElement = getGUIEnvironment()->getFocus();
+	bool editing = focusElement && focusElement->getType() == irr::gui::EGUIET_EDIT_BOX;
+	auto textView = (NSTextView*)[NSApp delegate];
+	// Fix mouse up events not being raised as a side effect of the IME workaround changing the frame
+	[textView setFrame:NSRect()]; // This sets the NSWindow frame to 0 via the delegate
+	if (!editing)
+	{
+		[Window makeFirstResponder:nil];
+	}
+	else
+	{
+		// Send input events to fake NSTextView that is also the AppDelegate
+		[Window makeFirstResponder:textView];
+	}
+
 	event = [NSApp nextEventMatchingMask:NSAnyEventMask untilDate:[NSDate distantPast] inMode:NSDefaultRunLoopMode dequeue:YES];
 	if (event != nil)
 	{
@@ -979,6 +1031,22 @@
 		switch([(NSEvent *)event type])
 		{
 			case NSKeyDown:
+				if (editing)
+				{
+					auto crect = focusElement->getAbsolutePosition();
+					// Ensure font height is enough to fill the edit box so the IME window doesn't overlap it
+					[textView setFont:[NSFont userFontOfSize:crect.getHeight()]];
+					// Change origin from top left to bottom right
+					NSRect rect = {
+						crect.UpperLeftCorner.X,
+						[[textView superview] frame].size.height - crect.LowerRightCorner.Y,
+						crect.getWidth(), crect.getHeight(),
+					};
+					// Workaround for correct IME positioning below the edit box
+					[textView setFrame:rect]; // Reset to 0 at the start of the loop to not break other events
+					[NSApp sendEvent:event]; // Delegate to fake text edit control to handle text input
+					break;
+				}
 				postKeyEvent(event,ievent,true);
 				break;
 
@@ -1148,7 +1216,7 @@
 
 bool CIrrDeviceMacOSX::isWindowActive() const
 {
-	return (IsActive);
+	return IsActive && Window != NULL && [Window occlusionState] & NSWindowOcclusionStateVisible;
 }
 
 
@@ -1199,22 +1267,22 @@
 			}
 			else
 			{
-				cStr = (unsigned char *)[str cStringUsingEncoding:NSWindowsCP1252StringEncoding];
+				cStr = (unsigned char *)[str UTF8String];
 				if (cStr != NULL && strlen((char*)cStr) > 0)
 				{
 					mchar = cStr[0];
 					mkey = toupper(mchar);
-					if ([(NSEvent *)event modifierFlags] & NSCommandKeyMask)
-					{
-						if (mkey == 'C' || mkey == 'V' || mkey == 'X')
-						{
-							mchar = 0;
-							skipCommand = true;
-						}
-					}
 				}
 			}
 		}
+		if ([(NSEvent *)event modifierFlags] & NSCommandKeyMask)
+		{
+			if (mkey == 'A' || mkey == 'C' || mkey == 'V' || mkey == 'X')
+			{
+				mchar = 0;
+				skipCommand = true;
+			}
+		}
 
 		ievent.EventType = irr::EET_KEY_INPUT_EVENT;
 		ievent.KeyInput.Key = (irr::EKEY_CODE)mkey;
@@ -1225,8 +1293,6 @@
 
 		if (skipCommand)
 			ievent.KeyInput.Control = true;
-		else if ([(NSEvent *)event modifierFlags] & NSCommandKeyMask)
-			[NSApp sendEvent:(NSEvent *)event];
 
 		postEventFromUser(ievent);
 	}
@@ -1258,6 +1324,9 @@
 			post = false;
 	}
 
+	ievent.MouseInput.Shift = ([(NSEvent *)event modifierFlags] & NSShiftKeyMask) != 0;
+	ievent.MouseInput.Control = ([(NSEvent *)event modifierFlags] & NSControlKeyMask) != 0;
+
 	if (post)
 		postEventFromUser(ievent);
 
diff -ur source/Irrlicht/MacOSX/OSXClipboard.mm source-fixed/Irrlicht/MacOSX/OSXClipboard.mm
--- source/Irrlicht/MacOSX/OSXClipboard.mm	2019-10-03 18:30:22.000000000 -0400
+++ source-fixed/Irrlicht/MacOSX/OSXClipboard.mm	2019-10-03 18:31:24.000000000 -0400
@@ -13,7 +13,7 @@
 
 	if ((text != NULL) && (strlen(text) > 0))
 	{
-		str = [NSString stringWithCString:text encoding:NSWindowsCP1252StringEncoding];
+		str = [NSString stringWithUTF8String:text];
 		board = [NSPasteboard generalPasteboard];
 		[board declareTypes:[NSArray arrayWithObject:NSStringPboardType] owner:NSApp];
 		[board setString:str forType:NSStringPboardType];
@@ -30,7 +30,7 @@
 	board = [NSPasteboard generalPasteboard];
 	str = [board stringForType:NSStringPboardType];
 	if (str != nil)
-		result = (char*)[str cStringUsingEncoding:NSWindowsCP1252StringEncoding];
+		result = (char*)[str UTF8String];
 	return (result);
 }
 
diff -ur source/Irrlicht/libpng/pngpriv.h source-fixed/Irrlicht/libpng/pngpriv.h
--- source/Irrlicht/libpng/pngpriv.h	2019-10-03 18:30:22.000000000 -0400
+++ source-fixed/Irrlicht/libpng/pngpriv.h	2019-10-03 18:31:24.000000000 -0400
@@ -798,7 +798,7 @@
  * must match that used in the build, or we must be using pnglibconf.h.prebuilt:
  */
 #if PNG_ZLIB_VERNUM != 0 && PNG_ZLIB_VERNUM != ZLIB_VERNUM
-#  error ZLIB_VERNUM != PNG_ZLIB_VERNUM \
+#  warning ZLIB_VERNUM != PNG_ZLIB_VERNUM \
       "-I (include path) error: see the notes in pngpriv.h"
    /* This means that when pnglibconf.h was built the copy of zlib.h that it
     * used is not the same as the one being used here.  Because the build of
diff -ur include/IVideoDriver.h include-fixed/IVideoDriver.h
--- include/IVideoDriver.h	2016-06-26 17:14:38.000000000 -0400
+++ include-fixed/IVideoDriver.h	2020-01-28 08:51:49.000000000 -0500
@@ -931,6 +931,12 @@
 				SColor colorLeftDown, SColor colorRightDown,
 				const core::rect<s32>* clip =0) =0;

+
+		virtual void draw2DRectangleClip(const core::rect<s32>& pos,
+				SColor colorLeftUp, SColor colorRightUp,
+				SColor colorLeftDown, SColor colorRightDown,
+				const core::rect<s32>* clamp =0, const core::rect<s32>* clip =0) =0;
+
 		//! Draws the outline of a 2D rectangle.
 		/** \param pos Position of the rectangle.
 		\param color Color of the rectangle to draw. The alpha component
diff -ur source/Irrlicht/CD3D9Driver.cpp source-fixed/Irrlicht/CD3D9Driver.cpp
--- source/Irrlicht/CD3D9Driver.cpp
+++ source-fixed/Irrlicht/CD3D9Driver.cpp
@@ -384,9 +384,16 @@ bool CD3D9Driver::initDriver(HWND hwnd, bool pureSoftware)
 	}
 	else
 	{
-		HRESULT hr = pID3D->CreateDevice(adapter, devtype, hwnd,
+		HRESULT hr = pID3D->CreateDevice(0, devtype, hwnd,
 				fpuPrecision | multithreaded | D3DCREATE_HARDWARE_VERTEXPROCESSING, &present, &pID3DDevice);
-
+		/*hr = pID3D->CreateDevice(1, devtype, hwnd,
+								 fpuPrecision | multithreaded | D3DCREATE_HARDWARE_VERTEXPROCESSING, &present, &pID3DDevice);*/
+		/*
+		hr = pID3D->CreateDevice(2, devtype, hwnd,
+								 fpuPrecision | multithreaded | D3DCREATE_HARDWARE_VERTEXPROCESSING, &present, &pID3DDevice);*/
+		UINT b = 0;
+		D3DFORMAT c;
+		volatile int a = pID3D->GetAdapterCount();
 		if(FAILED(hr))
 			hr = pID3D->CreateDevice(adapter, devtype, hwnd,
 					fpuPrecision | multithreaded | D3DCREATE_MIXED_VERTEXPROCESSING , &present, &pID3DDevice);
@@ -1961,6 +1968,58 @@ void CD3D9Driver::draw2DRectangle(const core::rect<s32>& position,
 		D3DFMT_INDEX16, &vtx[0], sizeof(S3DVertex));
 }
 
+//!Draws a 2d rectangle with a gradient and proper clip.
+void CD3D9Driver::draw2DRectangleClip(const core::rect<s32>& position,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp, const core::rect<s32>* clipRect)
+{
+	core::rect<s32> pos(position);
+
+	if (clamp)
+		pos.clipAgainst(*clamp);
+
+	if (!pos.isValid())
+		return;
+
+	S3DVertex vtx[4];
+	vtx[0] = S3DVertex((f32)pos.UpperLeftCorner.X, (f32)pos.UpperLeftCorner.Y, 0.0f,
+			0.0f, 0.0f, 0.0f, colorLeftUp, 0.0f, 0.0f);
+	vtx[1] = S3DVertex((f32)pos.LowerRightCorner.X, (f32)pos.UpperLeftCorner.Y, 0.0f,
+			0.0f, 0.0f, 0.0f, colorRightUp, 0.0f, 1.0f);
+	vtx[2] = S3DVertex((f32)pos.LowerRightCorner.X, (f32)pos.LowerRightCorner.Y, 0.0f,
+			0.0f, 0.0f, 0.0f, colorRightDown, 1.0f, 0.0f);
+	vtx[3] = S3DVertex((f32)pos.UpperLeftCorner.X, (f32)pos.LowerRightCorner.Y, 0.0f,
+			0.0f, 0.0f, 0.0f, colorLeftDown, 1.0f, 1.0f);
+
+	s16 indices[6] = {0,1,2,0,2,3};
+
+	setRenderStates2DMode(
+		colorLeftUp.getAlpha() < 255 ||
+		colorRightUp.getAlpha() < 255 ||
+		colorLeftDown.getAlpha() < 255 ||
+		colorRightDown.getAlpha() < 255, false, false);
+
+	setActiveTexture(0,0);
+
+	setVertexShader(EVT_STANDARD);
+
+	if(clipRect) {
+		pID3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
+		RECT scissor;
+		scissor.left = clipRect->UpperLeftCorner.X;
+		scissor.top = clipRect->UpperLeftCorner.Y;
+		scissor.right = clipRect->LowerRightCorner.X;
+		scissor.bottom = clipRect->LowerRightCorner.Y;
+		pID3DDevice->SetScissorRect(&scissor);
+	}
+
+	pID3DDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 4, 2, &indices[0],
+		D3DFMT_INDEX16, &vtx[0], sizeof(S3DVertex));
+
+	if(clipRect)
+		pID3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
+}
+
 
 //! Draws a 2d line.
 void CD3D9Driver::draw2DLine(const core::position2d<s32>& start,
@@ -3286,56 +3345,118 @@ IImage* CD3D9Driver::createScreenShot(video::ECOLOR_FORMAT format, video::E_REND
 		return 0;
 
 	// query the screen dimensions of the current adapter
-	D3DDISPLAYMODE displayMode;
-	pID3DDevice->GetDisplayMode(0, &displayMode);
+	/*D3DDISPLAYMODE displayMode;
+	pID3D->GetAdapterDisplayMode(0, &displayMode);
+	int totalScreens = pID3D->GetAdapterCount();
+	for(int i = 1; i < totalScreens; i++) {
+		D3DDISPLAYMODE tmpdisplayMode;
+		pID3D->GetAdapterDisplayMode(i, &tmpdisplayMode);
+		displayMode.Width += tmpdisplayMode.Width;
+	}*/
 
 	if (format==video::ECF_UNKNOWN)
 		format=video::ECF_A8R8G8B8;
 
 	// create the image surface to store the front buffer image [always A8R8G8B8]
+	//HRESULT hr;
+	//LPDIRECT3DSURFACE9 back_buffer;
+	//// read the back buffer into the image surface
+	//if (FAILED(hr = pID3DDevice->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &back_buffer)))
+	//{
+	//	back_buffer->Release();
+	//	return 0;
+	//}
+	//D3DSURFACE_DESC desc;
+	//back_buffer->GetDesc(&desc);
+	//LPDIRECT3DSURFACE9 lpSurface;
+	//if(FAILED(hr = pID3DDevice->CreateOffscreenPlainSurface(desc.Width, desc.Height, desc.Format, D3DPOOL_SYSTEMMEM, &lpSurface, 0)))
+	//	return 0;
+	//// try to load dll
+	io::path strDllName = "d3dx9_";
+	strDllName += (int)D3DX_SDK_VERSION;
+	strDllName += ".dll";
+
+	HMODULE hMod = LoadLibrary(strDllName.c_str());
+	typedef HRESULT(WINAPI *AAA)(LPD3DXBUFFER*             ppDestBuf,
+								 D3DXIMAGE_FILEFORMAT      DestFormat,
+								 LPDIRECT3DSURFACE9        pSrcSurface,
+								 CONST PALETTEENTRY*       pSrcPalette,
+								 CONST RECT*               pSrcRect);
+	typedef HRESULT(WINAPI *BBB)(LPCWSTR                   pDestFile,
+								 D3DXIMAGE_FILEFORMAT      DestFormat,
+								 LPDIRECT3DSURFACE9        pSrcSurface,
+								 CONST PALETTEENTRY*       pSrcPalette,
+								 CONST RECT*               pSrcRect);
+	static AAA D3DXSaveSurfaceToFileInmemory = 0;
+	static BBB D3DXSaveSurfaceTofile = 0;
+	if(hMod) {
+		D3DXSaveSurfaceToFileInmemory = (AAA)GetProcAddress(hMod, "D3DXSaveSurfaceToFileInMemory");
+		D3DXSaveSurfaceTofile = (BBB)GetProcAddress(hMod, "D3DXSaveSurfaceToFileW");
+	}
+	//	/*if(!pFn) {
+	//		LoadFailed = true;
+	//		os::Printer::log("Could not load shader function D3DXCompileShaderFromFileA from dll, shaders disabled",
+	//						 strDllName.c_str(), ELL_ERROR);
+	//	}*/
+		
+	//if(FAILED(hr = pID3DDevice->GetRenderTargetData(back_buffer, lpSurface)))
+	//	return 0;
+	//back_buffer->Release();
+
+	//// lock our area of the surface
+	//D3DLOCKED_RECT lockedRect;
+	//hr = lpSurface->LockRect(&lockedRect, NULL, D3DLOCK_READONLY);
+	//if (hr < 0)
+	//{
+	//	lpSurface->Release();
+	//	return 0;
+	//}
 	HRESULT hr;
-	LPDIRECT3DSURFACE9 lpSurface;
-	if (FAILED(hr = pID3DDevice->CreateOffscreenPlainSurface(displayMode.Width, displayMode.Height, D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &lpSurface, 0)))
-		return 0;
-
-	// read the front buffer into the image surface
-	if (FAILED(hr = pID3DDevice->GetFrontBufferData(0, lpSurface)))
 	{
+		D3DDISPLAYMODE displayMode;
+		pID3DDevice->GetDisplayMode(0, &displayMode);
+		LPDIRECT3DSURFACE9 lpSurface;
+		if(FAILED(hr = pID3DDevice->CreateOffscreenPlainSurface(1366+1024, displayMode.Height, D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &lpSurface, 0)))
+			return 0;
+
+		// read the front buffer into the image surface
+		if(FAILED(hr = pID3DDevice->GetFrontBufferData(0, lpSurface))) {
+			lpSurface->Release();
+			return 0;
+		}
+		D3DXSaveSurfaceTofile(L"Desktop2.bmp", D3DXIFF_BMP, lpSurface, NULL, NULL);
 		lpSurface->Release();
-		return 0;
 	}
-
-	RECT clientRect;
-	{
-		POINT clientPoint;
-		clientPoint.x = 0;
-		clientPoint.y = 0;
-
-		ClientToScreen((HWND)getExposedVideoData().D3D9.HWnd, &clientPoint);
-
-		clientRect.left   = clientPoint.x;
-		clientRect.top	= clientPoint.y;
-		clientRect.right  = clientRect.left + ScreenSize.Width;
-		clientRect.bottom = clientRect.top  + ScreenSize.Height;
-
-		// window can be off-screen partly, we can't take screenshots from that
-		clientRect.left = core::max_(clientRect.left, 0l);
-		clientRect.top = core::max_(clientRect.top, 0l);
-		clientRect.right = core::min_(clientRect.right, (long)displayMode.Width);
-		clientRect.bottom = core::min_(clientRect.bottom, (long)displayMode.Height );
+	LPDIRECT3DSURFACE9 back_buffer = NULL;
+	pID3DDevice->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &back_buffer);
+	D3DLOCKED_RECT d3dlr;
+	D3DSURFACE_DESC desc;
+	LPDIRECT3DSURFACE9 offscreen_surface = NULL;
+	back_buffer->GetDesc(&desc);
+	if(FAILED(hr = pID3DDevice->CreateOffscreenPlainSurface(desc.Width, desc.Height, desc.Format, D3DPOOL_SYSTEMMEM, &offscreen_surface, NULL))) {
+		return 0;
 	}
+	//D3DXLoadSurfaceFromSurface()
+	//RECT a = { 0, 0, desc.Width, desc.Height };
 
-	// lock our area of the surface
-	D3DLOCKED_RECT lockedRect;
-	if (FAILED(lpSurface->LockRect(&lockedRect, &clientRect, D3DLOCK_READONLY)))
-	{
-		lpSurface->Release();
+	/*if(FAILED(hr = pID3DDevice->StretchRect(back_buffer, &a, offscreen_surface, &a, D3DTEXF_NONE))) {
+		return 0;
+	}*/
+	if(FAILED(hr = pID3DDevice->GetRenderTargetData(back_buffer, offscreen_surface))) {
+		offscreen_surface->Release();
+		back_buffer->Release();
 		return 0;
 	}
+	offscreen_surface->LockRect(&d3dlr, NULL, D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_READONLY);
+	LPD3DXBUFFER buffer;
+	/*D3DXSaveSurfaceToFileInmemory(&buffer, D3DXIFF_BMP, back_buffer, NULL, NULL);
+	volatile DWORD imSize = buffer->GetBufferSize();
+	volatile void* imgBuffer = buffer->GetBufferPointer();
+	buffer->Release();*/
 
 	irr::core::dimension2d<u32> shotSize;
-	shotSize.Width = core::min_( ScreenSize.Width, (u32)(clientRect.right-clientRect.left) );
-	shotSize.Height = core::min_( ScreenSize.Height, (u32)(clientRect.bottom-clientRect.top) );
+	shotSize.Width = desc.Width;
+	shotSize.Height = desc.Height;
 
 	// this could throw, but we aren't going to worry about that case very much
 	IImage* newImage = createImage(format, shotSize);
@@ -3344,12 +3465,12 @@ IImage* CD3D9Driver::createScreenShot(video::ECOLOR_FORMAT format, video::E_REND
 	{
 		// d3d pads the image, so we need to copy the correct number of bytes
 		u32* dP = (u32*)newImage->lock();
-		u8 * sP = (u8 *)lockedRect.pBits;
+		u8 * sP = (u8 *)d3dlr.pBits;
 
 		// If the display mode format doesn't promise anything about the Alpha value
 		// and it appears that it's not presenting 255, then we should manually
 		// set each pixel alpha value to 255.
-		if (D3DFMT_X8R8G8B8 == displayMode.Format && (0xFF000000 != (*dP & 0xFF000000)))
+		if (D3DFMT_X8R8G8B8 == desc.Format && (0xFF000000 != (*dP & 0xFF000000)))
 		{
 			for (u32 y = 0; y < shotSize.Height; ++y)
 			{
@@ -3359,7 +3480,7 @@ IImage* CD3D9Driver::createScreenShot(video::ECOLOR_FORMAT format, video::E_REND
 					sP += 4;
 				}
 
-				sP += lockedRect.Pitch - (4 * shotSize.Width);
+				sP += d3dlr.Pitch - (4 * shotSize.Width);
 			}
 		}
 		else
@@ -3367,19 +3488,22 @@ IImage* CD3D9Driver::createScreenShot(video::ECOLOR_FORMAT format, video::E_REND
 			for (u32 y = 0; y < shotSize.Height; ++y)
 			{
 				convertColor(sP, video::ECF_A8R8G8B8, shotSize.Width, dP, format);
-				sP += lockedRect.Pitch;
+				sP += d3dlr.Pitch;
 				dP += shotSize.Width;
 			}
 		}
 
 		newImage->unlock();
 	}
+	offscreen_surface->UnlockRect();
+	offscreen_surface->Release();
+	back_buffer->Release();
 
 	// we can unlock and release the surface
-	lpSurface->UnlockRect();
+	//lpSurface->UnlockRect();
 
 	// release the image surface
-	lpSurface->Release();
+	//lpSurface->Release();
 
 	// return status of save operation to caller
 	return newImage;
diff -ur source/Irrlicht/CD3D9Driver.h source-fixed/Irrlicht/CD3D9Driver.h
--- source/Irrlicht/CD3D9Driver.h
+++ source-fixed/Irrlicht/CD3D9Driver.h
@@ -183,6 +183,11 @@ namespace video
 			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
 			const core::rect<s32>* clip);
 
+		//!Draws an 2d rectangle with a gradient and proper clip.
+		virtual void draw2DRectangleClip(const core::rect<s32>& pos,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp = 0, const core::rect<s32>* clip = 0);
+
 		//! Draws a 2d line.
 		virtual void draw2DLine(const core::position2d<s32>& start,
 					const core::position2d<s32>& end,
diff -ur source/Irrlicht/CNullDriver.cpp source-fixed/Irrlicht/CNullDriver.cpp
--- source/Irrlicht/CNullDriver.cpp
+++ source-fixed/Irrlicht/CNullDriver.cpp
@@ -808,10 +808,18 @@ void CNullDriver::draw2DRectangle(SColor color, const core::rect<s32>& pos, cons
 //! Draws a 2d rectangle with a gradient.
 void CNullDriver::draw2DRectangle(const core::rect<s32>& pos,
 	SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
-	const core::rect<s32>* clip)
+	const core::rect<s32>* clamp)
 {
 }
 
+//! Draws a 2d rectangle with a gradient.
+void CNullDriver::draw2DRectangleClip(const core::rect<s32>& pos,
+	SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+	const core::rect<s32>* clamp, const core::rect<s32>* clip)
+{
+	draw2DRectangle(pos, colorLeftUp, colorRightUp, colorLeftDown, colorRightDown, clip);
+}
+
 
 
 //! Draws a 2d line.
diff -ur source/Irrlicht/CNullDriver.h source-fixed/Irrlicht/CNullDriver.h
--- source/Irrlicht/CNullDriver.h
+++ source-fixed/Irrlicht/CNullDriver.h
@@ -208,7 +208,12 @@ namespace video
 		//! Draws a 2d rectangle with a gradient.
 		virtual void draw2DRectangle(const core::rect<s32>& pos,
 			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
-			const core::rect<s32>* clip = 0);
+			const core::rect<s32>* clamp = 0);
+
+		//! Draws a 2d rectangle with a gradient.
+		virtual void draw2DRectangleClip(const core::rect<s32>& pos,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp = 0, const core::rect<s32>* clip = 0);
 
 		//! Draws the outline of a 2d rectangle
 		virtual void draw2DRectangleOutline(const core::recti& pos, SColor color=SColor(255,255,255,255));
diff -ur source/Irrlicht/COpenGLDriver.cpp source-fixed/Irrlicht/COpenGLDriver.cpp
--- source/Irrlicht/COpenGLDriver.cpp
+++ source-fixed/Irrlicht/COpenGLDriver.cpp
@@ -2379,6 +2379,60 @@ void COpenGLDriver::draw2DRectangle(const core::rect<s32>& position,
 }
 
 
+void COpenGLDriver::draw2DRectangleClip(const core::rect<s32>& position,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp, const core::rect<s32>* clipRect)
+{
+	core::rect<s32> pos = position;
+
+	if (clamp)
+		pos.clipAgainst(*clamp);
+
+	if (!pos.isValid())
+		return;
+
+	disableTextures();
+
+	if (clipRect)
+	{
+		if (!clipRect->isValid())
+			return;
+
+		glEnable(GL_SCISSOR_TEST);
+		const core::dimension2d<u32>& renderTargetSize = getCurrentRenderTargetSize();
+		glScissor(clipRect->UpperLeftCorner.X, renderTargetSize.Height-clipRect->LowerRightCorner.Y,
+			clipRect->getWidth(), clipRect->getHeight());
+	}
+
+	setRenderStates2DMode(colorLeftUp.getAlpha() < 255 ||
+		colorRightUp.getAlpha() < 255 ||
+		colorLeftDown.getAlpha() < 255 ||
+		colorRightDown.getAlpha() < 255, false, false);
+
+	glBegin(GL_QUADS);
+	glColor4ub(colorLeftUp.getRed(), colorLeftUp.getGreen(),
+		colorLeftUp.getBlue(), colorLeftUp.getAlpha());
+	glVertex2f(GLfloat(pos.UpperLeftCorner.X), GLfloat(pos.UpperLeftCorner.Y));
+
+	glColor4ub(colorRightUp.getRed(), colorRightUp.getGreen(),
+		colorRightUp.getBlue(), colorRightUp.getAlpha());
+	glVertex2f(GLfloat(pos.LowerRightCorner.X), GLfloat(pos.UpperLeftCorner.Y));
+
+	glColor4ub(colorRightDown.getRed(), colorRightDown.getGreen(),
+		colorRightDown.getBlue(), colorRightDown.getAlpha());
+	glVertex2f(GLfloat(pos.LowerRightCorner.X), GLfloat(pos.LowerRightCorner.Y));
+
+	glColor4ub(colorLeftDown.getRed(), colorLeftDown.getGreen(),
+		colorLeftDown.getBlue(), colorLeftDown.getAlpha());
+	glVertex2f(GLfloat(pos.UpperLeftCorner.X), GLfloat(pos.LowerRightCorner.Y));
+
+	glEnd();
+
+	if(clipRect)
+		glDisable(GL_SCISSOR_TEST);
+}
+
+
 //! Draws a 2d line.
 void COpenGLDriver::draw2DLine(const core::position2d<s32>& start,
 				const core::position2d<s32>& end, SColor color)
diff -ur source/Irrlicht/COpenGLDriver.h source-fixed/Irrlicht/COpenGLDriver.h
--- source/Irrlicht/COpenGLDriver.h
+++ source-fixed/Irrlicht/COpenGLDriver.h
@@ -201,6 +201,11 @@ namespace video
 			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
 			const core::rect<s32>* clip = 0);
 
+		//!Draws an 2d rectangle with a gradient and proper clip.
+		virtual void draw2DRectangleClip(const core::rect<s32>& pos,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp = 0, const core::rect<s32>* clip = 0);
+
 		//! Draws a 2d line.
 		virtual void draw2DLine(const core::position2d<s32>& start,
 					const core::position2d<s32>& end,
