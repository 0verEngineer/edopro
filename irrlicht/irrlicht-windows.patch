diff -ur --strip-trailing-cr irrlicht/src/Irrlicht.cpp irrlicht-fixed/src/Irrlicht.cpp
--- irrlicht/src/Irrlicht.cpp	2012-11-03 14:08:00.000000000 -0400
+++ irrlicht-fixed/src/Irrlicht.cpp	2019-06-30 15:41:56.327847700 -0400
@@ -127,7 +127,7 @@
 } // end namespace irr
 
 
-#if defined(_IRR_WINDOWS_API_)
+#if defined(_IRR_WINDOWS_API_) && !defined(_IRR_STATIC_LIB_)
 
 BOOL APIENTRY DllMain( HANDLE hModule,
                        DWORD  ul_reason_for_call,
diff -ur --strip-trailing-cr irrlicht/include/IOSOperator.h irrlicht-fixed/include/IOSOperator.h
--- irrlicht/include/IOSOperator.h	2012-11-03 19:08:34.000000000 +0800
+++ irrlicht-fixed/include/IOSOperator.h	2017-09-09 18:50:04.693119800 +0800
@@ -26,11 +26,11 @@
 	}
 
 	//! Copies text to the clipboard
-	virtual void copyToClipboard(const c8* text) const = 0;
+	virtual void copyToClipboard(const c16* text) const = 0;
 
 	//! Get text from the clipboard
 	/** \return Returns 0 if no string is in there. */
-	virtual const c8* getTextFromClipboard() const = 0;
+	virtual const c16* getTextFromClipboard() const = 0;
 
 	//! Get the processor speed in megahertz
 	/** \param MHz The integer variable to store the speed in.
diff -ur --strip-trailing-cr irrlicht/include/irrTypes.h irrlicht-fixed/include/irrTypes.h
--- irrlicht/include/irrTypes.h	2012-11-19 18:20:40.000000000 +0800
+++ irrlicht-fixed/include/irrTypes.h	2017-09-09 18:54:19.126672600 +0800
@@ -48,6 +48,9 @@
 typedef signed short		s16;
 #endif
 
+//! 16 bit character variable.
+/** This is a typedef for wchar_t, it ensures portability of the engine. */
+typedef wchar_t			c16;
 
 
 //! 32 bit unsigned variable.
diff -ur --strip-trailing-cr irrlicht/src/CFileSystem.cpp irrlicht-fixed/src/CFileSystem.cpp
--- irrlicht/src/CFileSystem.cpp	2016-05-26 06:09:34.000000000 -0400
+++ irrlicht-fixed/src/CFileSystem.cpp	2020-02-20 20:32:26.866999100 -0500
@@ -840,7 +840,7 @@
 		#ifdef _IRR_WINDOWS_API_
 		#if !defined ( _WIN32_WCE )
 
-		r = new CFileList(Path, true, false);
+		r = new CFileList(Path, false, false);
 
 		// TODO: Should be unified once mingw adapts the proper types
 #if defined(__GNUC__)
diff -ur --strip-trailing-cr irrlicht/src/CGUIEditBox.cpp irrlicht-fixed/src/CGUIEditBox.cpp
--- irrlicht/src/CGUIEditBox.cpp	2014-09-17 20:23:10.000000000 +0800
+++ irrlicht-fixed/src/CGUIEditBox.cpp	2017-09-09 18:50:04.709120800 +0800
@@ -287,7 +287,7 @@
 				const s32 realmbgn = MarkBegin < MarkEnd ? MarkBegin : MarkEnd;
 				const s32 realmend = MarkBegin < MarkEnd ? MarkEnd : MarkBegin;
 
-				core::stringc s;
+				core::stringw s;
 				s = Text.subString(realmbgn, realmend - realmbgn).c_str();
 				Operator->copyToClipboard(s.c_str());
 			}
@@ -300,7 +300,7 @@
 				const s32 realmend = MarkBegin < MarkEnd ? MarkEnd : MarkBegin;
 
 				// copy
-				core::stringc sc;
+				core::stringw sc;
 				sc = Text.subString(realmbgn, realmend - realmbgn).c_str();
 				Operator->copyToClipboard(sc.c_str());
 
@@ -330,16 +330,10 @@
 				const s32 realmend = MarkBegin < MarkEnd ? MarkEnd : MarkBegin;
 
 				// add new character
-				const c8* p = Operator->getTextFromClipboard();
+				const c16* p = Operator->getTextFromClipboard();
 				if (p)
 				{
-					// TODO: we should have such a function in core::string
-					size_t lenOld = strlen(p);
-					wchar_t *ws = new wchar_t[lenOld + 1];
-					size_t len = mbstowcs(ws,p,lenOld);
-					ws[len] = 0;
-					irr::core::stringw widep(ws);
-					delete[] ws;
+					irr::core::stringw widep(p);
 
 					if (MarkBegin == MarkEnd)
 					{
@@ -664,6 +658,16 @@
 	case KEY_ESCAPE:
 	case KEY_TAB:
 	case KEY_SHIFT:
+	case KEY_LSHIFT:
+	case KEY_RSHIFT:
+	case KEY_MENU:
+	case KEY_LMENU:
+	case KEY_RMENU:
+	case KEY_LWIN:
+	case KEY_RWIN:
+	case KEY_CAPITAL:
+	case KEY_NUMLOCK:
+	case KEY_SCROLL:
 	case KEY_F1:
 	case KEY_F2:
 	case KEY_F3:
diff -ur --strip-trailing-cr irrlicht/src/CGUIListBox.cpp irrlicht-fixed/src/CGUIListBox.cpp
--- irrlicht/src/CGUIListBox.cpp	2016-05-26 12:09:34.000000000 +0800
+++ irrlicht-fixed/src/CGUIListBox.cpp	2017-09-09 18:50:04.720121400 +0800
@@ -425,7 +425,7 @@
 				}
 
 				case EMIE_MOUSE_MOVED:
-					if (Selecting || MoveOverSelect)
+					if (MoveOverSelect)
 					{
 						if (isPointInside(p))
 						{
diff -ur --strip-trailing-cr irrlicht/src/CIrrDeviceWin32.cpp irrlicht-fixed/src/CIrrDeviceWin32.cpp
--- irrlicht/src/CIrrDeviceWin32.cpp	2016-05-26 12:09:34.000000000 +0800
+++ irrlicht-fixed/src/CIrrDeviceWin32.cpp	2017-09-09 18:56:09.679995900 +0800
@@ -20,6 +20,8 @@
 #include "COSOperator.h"
 #include "dimension2d.h"
 #include "IGUISpriteBank.h"
+#include "IGUIEnvironment.h"
+#include "IGUIElement.h"
 #include <winuser.h>
 #if defined(_IRR_COMPILE_WITH_JOYSTICK_EVENTS_)
 #ifdef _IRR_COMPILE_WITH_DIRECTINPUT_JOYSTICK_
@@ -749,6 +751,26 @@
 		return 0;
 	}
 
+	{
+		dev = getDeviceFromHWnd(hWnd);
+		if (dev)
+		{
+			irr::gui::IGUIElement* ele = dev->getGUIEnvironment()->getFocus();
+			if (!ele || (ele->getType() != irr::gui::EGUIET_EDIT_BOX) || !ele->isEnabled())
+			{
+				HIMC hIMC = ImmGetContext(hWnd);
+				if (hIMC)
+				{
+					ImmNotifyIME(hIMC, NI_COMPOSITIONSTR, CPS_COMPLETE, 0);
+					ImmReleaseContext(hWnd, hIMC);
+				}
+				ImmAssociateContextEx(hWnd, NULL, 0);
+			}
+			else
+				ImmAssociateContextEx(hWnd, NULL, IACE_DEFAULT);
+		}
+	}
+
 	switch (message)
 	{
 	case WM_PAINT:
@@ -773,7 +795,11 @@
 			event.KeyInput.Key = (irr::EKEY_CODE)wParam;
 			event.KeyInput.PressedDown = (message==WM_KEYDOWN || message == WM_SYSKEYDOWN);
 
+#ifdef MAPVK_VSC_TO_VK_EX
+			const UINT MY_MAPVK_VSC_TO_VK_EX = MAPVK_VSC_TO_VK_EX;
+#else
 			const UINT MY_MAPVK_VSC_TO_VK_EX = 3; // MAPVK_VSC_TO_VK_EX should be in SDK according to MSDN, but isn't in mine.
+#endif
 			if ( event.KeyInput.Key == irr::KEY_SHIFT )
 			{
 				// this will fail on systems before windows NT/2000/XP, not sure _what_ will return there instead.
@@ -904,6 +930,53 @@
 		KEYBOARD_INPUT_HKL = GetKeyboardLayout(0);
 		KEYBOARD_INPUT_CODEPAGE = LocaleIdToCodepage( LOWORD(KEYBOARD_INPUT_HKL) );
 		return 0;
+
+	case WM_IME_STARTCOMPOSITION:
+		{
+			dev = getDeviceFromHWnd(hWnd);
+			irr::gui::IGUIElement* ele = dev->getGUIEnvironment()->getFocus();
+			if (!ele)
+				break;
+			irr::core::position2di pos = ele->getAbsolutePosition().UpperLeftCorner;
+			COMPOSITIONFORM CompForm = { CFS_POINT, { pos.X, pos.Y + ele->getAbsolutePosition().getHeight() } };
+			HIMC hIMC = ImmGetContext(hWnd);
+			ImmSetCompositionWindow(hIMC, &CompForm);
+			ImmReleaseContext(hWnd, hIMC);
+		}
+		break;
+
+	case WM_IME_CHAR:
+		event.EventType = irr::EET_KEY_INPUT_EVENT;
+		event.KeyInput.PressedDown = true;
+#ifdef _UNICODE
+		event.KeyInput.Char = wParam;
+#else
+		BYTE ch[3];
+		if (wParam >> 8) {
+			ch[0] = wParam >> 8;
+			ch[1] = wParam & 0xff;
+			ch[2] = 0;
+		} else {
+			ch[0] = wParam;
+			ch[1] = 0;
+		}
+		WORD unicodeChar;
+		MultiByteToWideChar(
+			KEYBOARD_INPUT_CODEPAGE,
+			MB_PRECOMPOSED, // default
+			(LPCSTR)ch,
+			sizeof(wParam),
+			(WCHAR*)&unicodeChar,
+			1);
+		event.KeyInput.Char = unicodeChar;
+#endif
+		event.KeyInput.Key = irr::KEY_ACCEPT;
+		event.KeyInput.Shift = 0;
+		event.KeyInput.Control = 0;
+		dev = getDeviceFromHWnd(hWnd);
+		if (dev)
+			dev->postEventFromUser(event);
+		return 0;
 	}
 	return DefWindowProc(hWnd, message, wParam, lParam);
 }
@@ -1797,8 +1870,8 @@
 
 	while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
 	{
-		// No message translation because we don't use WM_CHAR and it would conflict with our
-		// deadkey handling.
+		// conflict with deadkey handling.
+		TranslateMessage(&msg);
 
 		if (ExternalWindow && msg.hwnd == HWnd)
 			WndProc(HWnd, msg.message, msg.wParam, msg.lParam);
diff -ur --strip-trailing-cr irrlicht/src/COSOperator.cpp irrlicht-fixed/src/COSOperator.cpp
--- irrlicht/src/COSOperator.cpp	2012-11-03 19:07:52.000000000 +0800
+++ irrlicht-fixed/src/COSOperator.cpp	2017-09-09 18:50:04.715121100 +0800
@@ -52,9 +52,9 @@
 
 
 //! copies text to the clipboard
-void COSOperator::copyToClipboard(const c8* text) const
+void COSOperator::copyToClipboard(const c16* text) const
 {
-	if (strlen(text)==0)
+	if (wcslen(text)==0)
 		return;
 
 // Windows version
@@ -66,15 +66,15 @@
 	EmptyClipboard();
 
 	HGLOBAL clipbuffer;
-	char * buffer;
+	wchar_t * buffer;
 
-	clipbuffer = GlobalAlloc(GMEM_DDESHARE, strlen(text)+1);
-	buffer = (char*)GlobalLock(clipbuffer);
+	clipbuffer = GlobalAlloc(GMEM_DDESHARE, sizeof(wchar_t) * (wcslen(text) + 1));
+	buffer = (wchar_t*)GlobalLock(clipbuffer);
 
-	strcpy(buffer, text);
+	wcscpy(buffer, text);
 
 	GlobalUnlock(clipbuffer);
-	SetClipboardData(CF_TEXT, clipbuffer);
+	SetClipboardData(CF_UNICODETEXT, clipbuffer);
 	CloseClipboard();
 
 // MacOSX version
@@ -93,7 +93,7 @@
 
 //! gets text from the clipboard
 //! \return Returns 0 if no string is in there.
-const c8* COSOperator::getTextFromClipboard() const
+const c16* COSOperator::getTextFromClipboard() const
 {
 #if defined(_IRR_XBOX_PLATFORM_)
 		return 0;
@@ -101,10 +101,10 @@
 	if (!OpenClipboard(NULL))
 		return 0;
 
-	char * buffer = 0;
+	wchar_t * buffer = 0;
 
-	HANDLE hData = GetClipboardData( CF_TEXT );
-	buffer = (char*)GlobalLock( hData );
+	HANDLE hData = GetClipboardData( CF_UNICODETEXT );
+	buffer = (wchar_t*)GlobalLock( hData );
 	GlobalUnlock( hData );
 	CloseClipboard();
 	return buffer;
diff -ur --strip-trailing-cr irrlicht/src/COSOperator.h irrlicht-fixed/src/COSOperator.h
--- irrlicht/src/COSOperator.h	2012-11-03 19:08:00.000000000 +0800
+++ irrlicht-fixed/src/COSOperator.h	2017-09-09 18:50:04.717121200 +0800
@@ -27,11 +27,11 @@
 	virtual const core::stringc& getOperatingSystemVersion() const;
 
 	//! copies text to the clipboard
-	virtual void copyToClipboard(const c8* text) const;
+	virtual void copyToClipboard(const c16* text) const;
 
 	//! gets text from the clipboard
 	//! \return Returns 0 if no string is in there.
-	virtual const c8* getTextFromClipboard() const;
+	virtual const c16* getTextFromClipboard() const;
 
 	//! gets the processor speed in megahertz
 	//! \param Mhz:
diff -ur --strip-trailing-cr irrlicht/include/IVideoDriver.h irrlicht-fixed/include/IVideoDriver.h
--- irrlicht/include/IVideoDriver.h	2016-06-26 17:14:38.000000000 -0400
+++ irrlicht-fixed/include/IVideoDriver.h	2020-01-28 08:51:49.000000000 -0500
@@ -931,6 +931,12 @@
 				SColor colorLeftDown, SColor colorRightDown,
 				const core::rect<s32>* clip =0) =0;

+
+		virtual void draw2DRectangleClip(const core::rect<s32>& pos,
+				SColor colorLeftUp, SColor colorRightUp,
+				SColor colorLeftDown, SColor colorRightDown,
+				const core::rect<s32>* clamp =0, const core::rect<s32>* clip =0) =0;
+
 		//! Draws the outline of a 2D rectangle.
 		/** \param pos Position of the rectangle.
 		\param color Color of the rectangle to draw. The alpha component
diff -ur --strip-trailing-cr irrlicht/src/CD3D9Driver.cpp irrlicht-fixed/src/CD3D9Driver.cpp
--- irrlicht/src/CD3D9Driver.cpp
+++ irrlicht-fixed/src/CD3D9Driver.cpp
@@ -384,9 +384,16 @@ bool CD3D9Driver::initDriver(HWND hwnd, bool pureSoftware)
 	}
 	else
 	{
-		HRESULT hr = pID3D->CreateDevice(adapter, devtype, hwnd,
+		HRESULT hr = pID3D->CreateDevice(0, devtype, hwnd,
 				fpuPrecision | multithreaded | D3DCREATE_HARDWARE_VERTEXPROCESSING, &present, &pID3DDevice);
-
+		/*hr = pID3D->CreateDevice(1, devtype, hwnd,
+								 fpuPrecision | multithreaded | D3DCREATE_HARDWARE_VERTEXPROCESSING, &present, &pID3DDevice);*/
+		/*
+		hr = pID3D->CreateDevice(2, devtype, hwnd,
+								 fpuPrecision | multithreaded | D3DCREATE_HARDWARE_VERTEXPROCESSING, &present, &pID3DDevice);*/
+		UINT b = 0;
+		D3DFORMAT c;
+		volatile int a = pID3D->GetAdapterCount();
 		if(FAILED(hr))
 			hr = pID3D->CreateDevice(adapter, devtype, hwnd,
 					fpuPrecision | multithreaded | D3DCREATE_MIXED_VERTEXPROCESSING , &present, &pID3DDevice);
@@ -1961,6 +1968,58 @@ void CD3D9Driver::draw2DRectangle(const core::rect<s32>& position,
 		D3DFMT_INDEX16, &vtx[0], sizeof(S3DVertex));
 }
 
+//!Draws a 2d rectangle with a gradient and proper clip.
+void CD3D9Driver::draw2DRectangleClip(const core::rect<s32>& position,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp, const core::rect<s32>* clipRect)
+{
+	core::rect<s32> pos(position);
+
+	if (clamp)
+		pos.clipAgainst(*clamp);
+
+	if (!pos.isValid())
+		return;
+
+	S3DVertex vtx[4];
+	vtx[0] = S3DVertex((f32)pos.UpperLeftCorner.X, (f32)pos.UpperLeftCorner.Y, 0.0f,
+			0.0f, 0.0f, 0.0f, colorLeftUp, 0.0f, 0.0f);
+	vtx[1] = S3DVertex((f32)pos.LowerRightCorner.X, (f32)pos.UpperLeftCorner.Y, 0.0f,
+			0.0f, 0.0f, 0.0f, colorRightUp, 0.0f, 1.0f);
+	vtx[2] = S3DVertex((f32)pos.LowerRightCorner.X, (f32)pos.LowerRightCorner.Y, 0.0f,
+			0.0f, 0.0f, 0.0f, colorRightDown, 1.0f, 0.0f);
+	vtx[3] = S3DVertex((f32)pos.UpperLeftCorner.X, (f32)pos.LowerRightCorner.Y, 0.0f,
+			0.0f, 0.0f, 0.0f, colorLeftDown, 1.0f, 1.0f);
+
+	s16 indices[6] = {0,1,2,0,2,3};
+
+	setRenderStates2DMode(
+		colorLeftUp.getAlpha() < 255 ||
+		colorRightUp.getAlpha() < 255 ||
+		colorLeftDown.getAlpha() < 255 ||
+		colorRightDown.getAlpha() < 255, false, false);
+
+	setActiveTexture(0,0);
+
+	setVertexShader(EVT_STANDARD);
+
+	if(clipRect) {
+		pID3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, TRUE);
+		RECT scissor;
+		scissor.left = clipRect->UpperLeftCorner.X;
+		scissor.top = clipRect->UpperLeftCorner.Y;
+		scissor.right = clipRect->LowerRightCorner.X;
+		scissor.bottom = clipRect->LowerRightCorner.Y;
+		pID3DDevice->SetScissorRect(&scissor);
+	}
+
+	pID3DDevice->DrawIndexedPrimitiveUP(D3DPT_TRIANGLELIST, 0, 4, 2, &indices[0],
+		D3DFMT_INDEX16, &vtx[0], sizeof(S3DVertex));
+
+	if(clipRect)
+		pID3DDevice->SetRenderState(D3DRS_SCISSORTESTENABLE, FALSE);
+}
+
 
 //! Draws a 2d line.
 void CD3D9Driver::draw2DLine(const core::position2d<s32>& start,
@@ -3286,56 +3345,118 @@ IImage* CD3D9Driver::createScreenShot(video::ECOLOR_FORMAT format, video::E_REND
 		return 0;
 
 	// query the screen dimensions of the current adapter
-	D3DDISPLAYMODE displayMode;
-	pID3DDevice->GetDisplayMode(0, &displayMode);
+	/*D3DDISPLAYMODE displayMode;
+	pID3D->GetAdapterDisplayMode(0, &displayMode);
+	int totalScreens = pID3D->GetAdapterCount();
+	for(int i = 1; i < totalScreens; i++) {
+		D3DDISPLAYMODE tmpdisplayMode;
+		pID3D->GetAdapterDisplayMode(i, &tmpdisplayMode);
+		displayMode.Width += tmpdisplayMode.Width;
+	}*/
 
 	if (format==video::ECF_UNKNOWN)
 		format=video::ECF_A8R8G8B8;
 
 	// create the image surface to store the front buffer image [always A8R8G8B8]
+	//HRESULT hr;
+	//LPDIRECT3DSURFACE9 back_buffer;
+	//// read the back buffer into the image surface
+	//if (FAILED(hr = pID3DDevice->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &back_buffer)))
+	//{
+	//	back_buffer->Release();
+	//	return 0;
+	//}
+	//D3DSURFACE_DESC desc;
+	//back_buffer->GetDesc(&desc);
+	//LPDIRECT3DSURFACE9 lpSurface;
+	//if(FAILED(hr = pID3DDevice->CreateOffscreenPlainSurface(desc.Width, desc.Height, desc.Format, D3DPOOL_SYSTEMMEM, &lpSurface, 0)))
+	//	return 0;
+	//// try to load dll
+	io::path strDllName = "d3dx9_";
+	strDllName += (int)D3DX_SDK_VERSION;
+	strDllName += ".dll";
+
+	HMODULE hMod = LoadLibrary(strDllName.c_str());
+	typedef HRESULT(WINAPI *AAA)(LPD3DXBUFFER*             ppDestBuf,
+								 D3DXIMAGE_FILEFORMAT      DestFormat,
+								 LPDIRECT3DSURFACE9        pSrcSurface,
+								 CONST PALETTEENTRY*       pSrcPalette,
+								 CONST RECT*               pSrcRect);
+	typedef HRESULT(WINAPI *BBB)(LPCWSTR                   pDestFile,
+								 D3DXIMAGE_FILEFORMAT      DestFormat,
+								 LPDIRECT3DSURFACE9        pSrcSurface,
+								 CONST PALETTEENTRY*       pSrcPalette,
+								 CONST RECT*               pSrcRect);
+	static AAA D3DXSaveSurfaceToFileInmemory = 0;
+	static BBB D3DXSaveSurfaceTofile = 0;
+	if(hMod) {
+		D3DXSaveSurfaceToFileInmemory = (AAA)GetProcAddress(hMod, "D3DXSaveSurfaceToFileInMemory");
+		D3DXSaveSurfaceTofile = (BBB)GetProcAddress(hMod, "D3DXSaveSurfaceToFileW");
+	}
+	//	/*if(!pFn) {
+	//		LoadFailed = true;
+	//		os::Printer::log("Could not load shader function D3DXCompileShaderFromFileA from dll, shaders disabled",
+	//						 strDllName.c_str(), ELL_ERROR);
+	//	}*/
+		
+	//if(FAILED(hr = pID3DDevice->GetRenderTargetData(back_buffer, lpSurface)))
+	//	return 0;
+	//back_buffer->Release();
+
+	//// lock our area of the surface
+	//D3DLOCKED_RECT lockedRect;
+	//hr = lpSurface->LockRect(&lockedRect, NULL, D3DLOCK_READONLY);
+	//if (hr < 0)
+	//{
+	//	lpSurface->Release();
+	//	return 0;
+	//}
 	HRESULT hr;
-	LPDIRECT3DSURFACE9 lpSurface;
-	if (FAILED(hr = pID3DDevice->CreateOffscreenPlainSurface(displayMode.Width, displayMode.Height, D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &lpSurface, 0)))
-		return 0;
-
-	// read the front buffer into the image surface
-	if (FAILED(hr = pID3DDevice->GetFrontBufferData(0, lpSurface)))
 	{
+		D3DDISPLAYMODE displayMode;
+		pID3DDevice->GetDisplayMode(0, &displayMode);
+		LPDIRECT3DSURFACE9 lpSurface;
+		if(FAILED(hr = pID3DDevice->CreateOffscreenPlainSurface(1366+1024, displayMode.Height, D3DFMT_A8R8G8B8, D3DPOOL_SCRATCH, &lpSurface, 0)))
+			return 0;
+
+		// read the front buffer into the image surface
+		if(FAILED(hr = pID3DDevice->GetFrontBufferData(0, lpSurface))) {
+			lpSurface->Release();
+			return 0;
+		}
+		D3DXSaveSurfaceTofile(L"Desktop2.bmp", D3DXIFF_BMP, lpSurface, NULL, NULL);
 		lpSurface->Release();
-		return 0;
 	}
-
-	RECT clientRect;
-	{
-		POINT clientPoint;
-		clientPoint.x = 0;
-		clientPoint.y = 0;
-
-		ClientToScreen((HWND)getExposedVideoData().D3D9.HWnd, &clientPoint);
-
-		clientRect.left   = clientPoint.x;
-		clientRect.top	= clientPoint.y;
-		clientRect.right  = clientRect.left + ScreenSize.Width;
-		clientRect.bottom = clientRect.top  + ScreenSize.Height;
-
-		// window can be off-screen partly, we can't take screenshots from that
-		clientRect.left = core::max_(clientRect.left, 0l);
-		clientRect.top = core::max_(clientRect.top, 0l);
-		clientRect.right = core::min_(clientRect.right, (long)displayMode.Width);
-		clientRect.bottom = core::min_(clientRect.bottom, (long)displayMode.Height );
+	LPDIRECT3DSURFACE9 back_buffer = NULL;
+	pID3DDevice->GetBackBuffer(0, 0, D3DBACKBUFFER_TYPE_MONO, &back_buffer);
+	D3DLOCKED_RECT d3dlr;
+	D3DSURFACE_DESC desc;
+	LPDIRECT3DSURFACE9 offscreen_surface = NULL;
+	back_buffer->GetDesc(&desc);
+	if(FAILED(hr = pID3DDevice->CreateOffscreenPlainSurface(desc.Width, desc.Height, desc.Format, D3DPOOL_SYSTEMMEM, &offscreen_surface, NULL))) {
+		return 0;
 	}
+	//D3DXLoadSurfaceFromSurface()
+	//RECT a = { 0, 0, desc.Width, desc.Height };
 
-	// lock our area of the surface
-	D3DLOCKED_RECT lockedRect;
-	if (FAILED(lpSurface->LockRect(&lockedRect, &clientRect, D3DLOCK_READONLY)))
-	{
-		lpSurface->Release();
+	/*if(FAILED(hr = pID3DDevice->StretchRect(back_buffer, &a, offscreen_surface, &a, D3DTEXF_NONE))) {
+		return 0;
+	}*/
+	if(FAILED(hr = pID3DDevice->GetRenderTargetData(back_buffer, offscreen_surface))) {
+		offscreen_surface->Release();
+		back_buffer->Release();
 		return 0;
 	}
+	offscreen_surface->LockRect(&d3dlr, NULL, D3DLOCK_NO_DIRTY_UPDATE | D3DLOCK_READONLY);
+	LPD3DXBUFFER buffer;
+	/*D3DXSaveSurfaceToFileInmemory(&buffer, D3DXIFF_BMP, back_buffer, NULL, NULL);
+	volatile DWORD imSize = buffer->GetBufferSize();
+	volatile void* imgBuffer = buffer->GetBufferPointer();
+	buffer->Release();*/
 
 	irr::core::dimension2d<u32> shotSize;
-	shotSize.Width = core::min_( ScreenSize.Width, (u32)(clientRect.right-clientRect.left) );
-	shotSize.Height = core::min_( ScreenSize.Height, (u32)(clientRect.bottom-clientRect.top) );
+	shotSize.Width = desc.Width;
+	shotSize.Height = desc.Height;
 
 	// this could throw, but we aren't going to worry about that case very much
 	IImage* newImage = createImage(format, shotSize);
@@ -3344,12 +3465,12 @@ IImage* CD3D9Driver::createScreenShot(video::ECOLOR_FORMAT format, video::E_REND
 	{
 		// d3d pads the image, so we need to copy the correct number of bytes
 		u32* dP = (u32*)newImage->lock();
-		u8 * sP = (u8 *)lockedRect.pBits;
+		u8 * sP = (u8 *)d3dlr.pBits;
 
 		// If the display mode format doesn't promise anything about the Alpha value
 		// and it appears that it's not presenting 255, then we should manually
 		// set each pixel alpha value to 255.
-		if (D3DFMT_X8R8G8B8 == displayMode.Format && (0xFF000000 != (*dP & 0xFF000000)))
+		if (D3DFMT_X8R8G8B8 == desc.Format && (0xFF000000 != (*dP & 0xFF000000)))
 		{
 			for (u32 y = 0; y < shotSize.Height; ++y)
 			{
@@ -3359,7 +3480,7 @@ IImage* CD3D9Driver::createScreenShot(video::ECOLOR_FORMAT format, video::E_REND
 					sP += 4;
 				}
 
-				sP += lockedRect.Pitch - (4 * shotSize.Width);
+				sP += d3dlr.Pitch - (4 * shotSize.Width);
 			}
 		}
 		else
@@ -3367,19 +3488,22 @@ IImage* CD3D9Driver::createScreenShot(video::ECOLOR_FORMAT format, video::E_REND
 			for (u32 y = 0; y < shotSize.Height; ++y)
 			{
 				convertColor(sP, video::ECF_A8R8G8B8, shotSize.Width, dP, format);
-				sP += lockedRect.Pitch;
+				sP += d3dlr.Pitch;
 				dP += shotSize.Width;
 			}
 		}
 
 		newImage->unlock();
 	}
+	offscreen_surface->UnlockRect();
+	offscreen_surface->Release();
+	back_buffer->Release();
 
 	// we can unlock and release the surface
-	lpSurface->UnlockRect();
+	//lpSurface->UnlockRect();
 
 	// release the image surface
-	lpSurface->Release();
+	//lpSurface->Release();
 
 	// return status of save operation to caller
 	return newImage;
diff -ur --strip-trailing-cr irrlicht/src/CD3D9Driver.h irrlicht-fixed/src/CD3D9Driver.h
--- irrlicht/src/CD3D9Driver.h
+++ irrlicht-fixed/src/CD3D9Driver.h
@@ -183,6 +183,11 @@ namespace video
 			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
 			const core::rect<s32>* clip);
 
+		//!Draws an 2d rectangle with a gradient and proper clip.
+		virtual void draw2DRectangleClip(const core::rect<s32>& pos,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp = 0, const core::rect<s32>* clip = 0);
+
 		//! Draws a 2d line.
 		virtual void draw2DLine(const core::position2d<s32>& start,
 					const core::position2d<s32>& end,
diff -ur --strip-trailing-cr irrlicht/src/CNullDriver.cpp irrlicht-fixed/src/CNullDriver.cpp
--- irrlicht/src/CNullDriver.cpp
+++ irrlicht-fixed/src/CNullDriver.cpp
@@ -808,10 +808,18 @@ void CNullDriver::draw2DRectangle(SColor color, const core::rect<s32>& pos, cons
 //! Draws a 2d rectangle with a gradient.
 void CNullDriver::draw2DRectangle(const core::rect<s32>& pos,
 	SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
-	const core::rect<s32>* clip)
+	const core::rect<s32>* clamp)
 {
 }
 
+//! Draws a 2d rectangle with a gradient.
+void CNullDriver::draw2DRectangleClip(const core::rect<s32>& pos,
+	SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+	const core::rect<s32>* clamp, const core::rect<s32>* clip)
+{
+	draw2DRectangle(pos, colorLeftUp, colorRightUp, colorLeftDown, colorRightDown, clip);
+}
+
 
 
 //! Draws a 2d line.
diff -ur --strip-trailing-cr irrlicht/src/CNullDriver.h irrlicht-fixed/src/CNullDriver.h
--- irrlicht/src/CNullDriver.h
+++ irrlicht-fixed/src/CNullDriver.h
@@ -208,7 +208,12 @@ namespace video
 		//! Draws a 2d rectangle with a gradient.
 		virtual void draw2DRectangle(const core::rect<s32>& pos,
 			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
-			const core::rect<s32>* clip = 0);
+			const core::rect<s32>* clamp = 0);
+
+		//! Draws a 2d rectangle with a gradient.
+		virtual void draw2DRectangleClip(const core::rect<s32>& pos,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp = 0, const core::rect<s32>* clip = 0);
 
 		//! Draws the outline of a 2d rectangle
 		virtual void draw2DRectangleOutline(const core::recti& pos, SColor color=SColor(255,255,255,255));
diff -ur --strip-trailing-cr irrlicht/src/COpenGLDriver.cpp irrlicht-fixed/src/COpenGLDriver.cpp
--- irrlicht/src/COpenGLDriver.cpp
+++ irrlicht-fixed/src/COpenGLDriver.cpp
@@ -2379,6 +2379,60 @@ void COpenGLDriver::draw2DRectangle(const core::rect<s32>& position,
 }
 
 
+void COpenGLDriver::draw2DRectangleClip(const core::rect<s32>& position,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp, const core::rect<s32>* clipRect)
+{
+	core::rect<s32> pos = position;
+
+	if (clamp)
+		pos.clipAgainst(*clamp);
+
+	if (!pos.isValid())
+		return;
+
+	disableTextures();
+
+	if (clipRect)
+	{
+		if (!clipRect->isValid())
+			return;
+
+		glEnable(GL_SCISSOR_TEST);
+		const core::dimension2d<u32>& renderTargetSize = getCurrentRenderTargetSize();
+		glScissor(clipRect->UpperLeftCorner.X, renderTargetSize.Height-clipRect->LowerRightCorner.Y,
+			clipRect->getWidth(), clipRect->getHeight());
+	}
+
+	setRenderStates2DMode(colorLeftUp.getAlpha() < 255 ||
+		colorRightUp.getAlpha() < 255 ||
+		colorLeftDown.getAlpha() < 255 ||
+		colorRightDown.getAlpha() < 255, false, false);
+
+	glBegin(GL_QUADS);
+	glColor4ub(colorLeftUp.getRed(), colorLeftUp.getGreen(),
+		colorLeftUp.getBlue(), colorLeftUp.getAlpha());
+	glVertex2f(GLfloat(pos.UpperLeftCorner.X), GLfloat(pos.UpperLeftCorner.Y));
+
+	glColor4ub(colorRightUp.getRed(), colorRightUp.getGreen(),
+		colorRightUp.getBlue(), colorRightUp.getAlpha());
+	glVertex2f(GLfloat(pos.LowerRightCorner.X), GLfloat(pos.UpperLeftCorner.Y));
+
+	glColor4ub(colorRightDown.getRed(), colorRightDown.getGreen(),
+		colorRightDown.getBlue(), colorRightDown.getAlpha());
+	glVertex2f(GLfloat(pos.LowerRightCorner.X), GLfloat(pos.LowerRightCorner.Y));
+
+	glColor4ub(colorLeftDown.getRed(), colorLeftDown.getGreen(),
+		colorLeftDown.getBlue(), colorLeftDown.getAlpha());
+	glVertex2f(GLfloat(pos.UpperLeftCorner.X), GLfloat(pos.LowerRightCorner.Y));
+
+	glEnd();
+
+	if(clipRect)
+		glDisable(GL_SCISSOR_TEST);
+}
+
+
 //! Draws a 2d line.
 void COpenGLDriver::draw2DLine(const core::position2d<s32>& start,
 				const core::position2d<s32>& end, SColor color)
diff -ur --strip-trailing-cr irrlicht/src/COpenGLDriver.h irrlicht-fixed/src/COpenGLDriver.h
--- irrlicht/src/COpenGLDriver.h
+++ irrlicht-fixed/src/COpenGLDriver.h
@@ -201,6 +201,11 @@ namespace video
 			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
 			const core::rect<s32>* clip = 0);
 
+		//!Draws an 2d rectangle with a gradient and proper clip.
+		virtual void draw2DRectangleClip(const core::rect<s32>& pos,
+			SColor colorLeftUp, SColor colorRightUp, SColor colorLeftDown, SColor colorRightDown,
+			const core::rect<s32>* clamp = 0, const core::rect<s32>* clip = 0);
+
 		//! Draws a 2d line.
 		virtual void draw2DLine(const core::position2d<s32>& start,
 					const core::position2d<s32>& end,
